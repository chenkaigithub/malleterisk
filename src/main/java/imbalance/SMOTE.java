package imbalance;

import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedList;
import java.util.Random;
import java.util.UUID;

import cc.mallet.types.Alphabet;
import cc.mallet.types.FeatureVector;
import cc.mallet.types.Instance;
import cc.mallet.types.InstanceList;
import cc.mallet.types.SparseVector;
import classifiers.KNN;

/**
 * Implements the SMOTE algorithm for class imbalance learning.
 * 
 * Chawla, Bowyer, Hall, Kegelmeyer - SMOTE : Synthetic Minority Over-sampling Technique
 * 
 * SMOTE is an oversampling technique that generates synthetic samples based on 
 * the k-nearest neighbours. Synthetic samples are generated by randomly selecting 
 * a nearest neighbour and adding it to the difference of the current instance to 
 * the neighbour. The synthetic sample's attributes are also randomly selected.
 * 
 * @author tt
 */
public class SMOTE extends DataBalancer {
	private static final Random random = new Random();
	private final int k; // number of nearest neighbours to be used
	
	public SMOTE(int k, int t) {
		super(t);
		this.k = k;
	}
	
//	public SMOTE(InstanceList instances, int k, int t) {
//		super(instances, t);
//		this.k = k;
//	}
	
	@Override
	protected Collection<Instance> balanceHook(InstanceList classInstances, int n) {
		// SMOTE only performs oversamping
		if(n > classInstances.size()) return classInstances;
		else return smote(classInstances, n, k);
	}
	
	// applies the SMOTE algorithm to the given instances
	// the instances should all belong to the target class (or classes, for combined smotting)
	public static final Collection<Instance> smote(InstanceList instances, int n, int k) {
		// create the new instancelist
		LinkedList<Instance> newInstances = new LinkedList<Instance>();
		
		Alphabet dataAlphabet = instances.getDataAlphabet();
		Alphabet targetAlphabet = instances.getTargetAlphabet();
		
		// fix k, in case the class is larger than the selected k
		int numInstances = instances.size();
		if(k > instances.size()) k = numInstances;
		
		// determine the number of new samples to be generated by SMOTE
		newInstances.addAll(instances); // we keep all previous samples
		n -= numInstances;
		n /= Math.floor(numInstances); // always returns a multiple of (n - numInstances)
		
		// smote every instance of the given instancelist
		for (Instance instance : instances) {
			// find the k nearest neighbours of instance
			Instance[] knn = KNN.knn(k, instance, instances);
			// create n synthetic instances based on the neighbours and add to new instancelist
			newInstances.addAll(populate(dataAlphabet, targetAlphabet, n, instance, knn));
		}
		
		return newInstances;
	}
	
	private static final Collection<Instance> populate(Alphabet dataAlphabet, Alphabet targetAlphabet, int n, Instance instance, Instance[] knn) {
		LinkedList<Instance> instances = new LinkedList<Instance>();

		// create n synthetic instances
		while(n>0) {
			// randomly select one of the knn instances'
			Instance selectedInstance = knn[random.nextInt(knn.length)];
			SparseVector sv1 = (SparseVector)instance.getData();
			SparseVector sv2 = (SparseVector)selectedInstance.getData();
			
			// synthetic = ((instance - selected_neighbour) + selected_neighbour).randomize_attributes()
			
			// sv = minus(instance, selectedInstance) | calculate the distance between vectors
			FeatureVector sv = (FeatureVector) sv1.cloneMatrix();
			sv.plusEqualsSparse(sv2, -1);
			// sv += selectedInstance | extend the vector over the border of the class
			sv.plusEqualsSparse(sv2);
			// randomly select attributes for the synthetic instance (1 or 0 to add/remove attributes)
			sv = randomizeAttributes(sv);

			// ATTN: not taking care of possibly empty instances! should I worry?
			instances.add(new Instance(sv, instance.getTarget(), UUID.randomUUID(), instance.getSource()));
			
			n--; // do this 'n' times
		}
		
		return instances;
	}
	
	// iterates all the attributes and randomly select
	private static final FeatureVector randomizeAttributes(FeatureVector sv) {
		int[] indices = sv.getIndices();
		double[] values = sv.getValues();
		
		int[] selectedIndices = new int[indices.length];
		double[] selectedValues = new double[values.length];
		int selectedCounter = 0;
		
		// iterate through all the features and randomly select them
		for(int idx : sv.getIndices()) {
			if(random.nextInt(2)==1) {
				selectedIndices[selectedCounter] = idx;
				selectedValues[selectedCounter++] = sv.value(idx);
			}
		}
		
		// if "for some reason" (like... probabilities) the number of selected features is
		// smaller than the original number of features, resize the arrays
		// ATTN: this could lead to a totally empty feature vector
		if(selectedCounter < indices.length) {
			Arrays.copyOf(selectedIndices, selectedCounter);
			Arrays.copyOf(selectedValues, selectedCounter);
		}
		
		return new FeatureVector(sv.getAlphabet(), selectedIndices, selectedValues);
	}
}
